---
title: "Introducci√≥n a los Arrays en Solidity"
datePublished: Sat Dec 07 2024 06:51:25 GMT+0000 (Coordinated Universal Time)
cuid: cm7sob388000408jr02u7fvwq
slug: introduccion-a-los-arrays-en-solidity
cover: https://cdn.hashnode.com/res/hashnode/image/upload/v1733550967086/300e455d-aa05-42e4-8595-04d4a97fb454.png

---


Los **arrays** son una de las estructuras de datos m√°s fundamentales. Permiten almacenar colecciones de elementos del mismo tipo y trabajar con ellos de manera eficiente. Aunque los arrays en Solidity tienen similitudes con otros lenguajes, hay caracter√≠sticas √∫nicas que vamos a explorar ahora. ¬°Comencemos!

---

## Declaraci√≥n y Uso B√°sico de Arrays

En Solidity, se puede declarar un array de dos maneras: de tama√±o fijo y din√°mico. Un array de tama√±o fijo es cuando sabes cuantos elementos va a tener tu array de antemano, y un array din√°mico es cuando no lo sabes.

Para declarar un array din√°mico de n√∫meros en Solidity, usamos la notaci√≥n `uint256[]`. Aqu√≠ hay un ejemplo de una funci√≥n que toma un array como entrada y simplemente lo retorna:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Arrays01 {
    function useArrayForUint256(
        uint256[] calldata input
    ) public pure returns (uint256[] memory) {
        return input;
    }
}
```

En **Remix**, tienes qu√© ingresar el input en este formato: `[1,2,3,4]` al llamar esta funci√≥n. Tambi√©n puedes declrar arrays de cualquier otro tipo, como `bool[]` o `address[]` pero los elementos del array siempre tienen qu√© ser del mismo tipo:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Arrays02 {
    function booleanArrayExample(
        bool[] calldata myArr
    ) public pure returns (bool[] memory) {
        return myArr;
    }

    function addressArrayExample(
        address[] calldata myArr
    ) public pure returns (address[] memory) {
        return myArr;
    }
}
```

---

## Storage locations: `calldata` y `memory`

¬°Felicidades por haber llegado hasta aqu√≠! Ahora vamos a ver el primer concepto que es 100% de desarrollo blockchain. Si has estado escribiendo t√∫ mism@ el c√≥digo ya habr√°s notado esas palabras clave `public`, `pure`, `calldata`, `memory` que no hemos explicado. Las primeras dos las vamos a explicar m√°s adelante y por ahora vamos a hablar un poco sobre las √∫ltimas dos.

Estoy seguro que sabes lo que es la EVM, es la **Ethereum Virtual Machine**, el *ambiente* en donde corre el c√≥digo que escribimos en Solidity, compilamos a *bytecode* y desplegamos a la blockchain. Bueno pues la EVM tiene este concepto llamado **storage locations**, que es justamente los diferentes lugares donde se puede almacenar la data que usan nuestros smart contracts. Las principales *storage locations* son `memory`, `storage` y `calldata` y tienen diferentes casos de uso para hacer nuestro c√≥digo m√°s eficiente. M√°s adelante veremos este concepto de *storage locations* mucho m√°s a fondo, por ahora agr√©galos a tu c√≥digo para que compile correctamente.

---

## Propiedades y M√©todos de Arrays

### Indexaci√≥n

Los arrays son **indexados desde cero**, como en otros lenguajes de programaci√≥n. Si intentas acceder a una posici√≥n que no existe, la transacci√≥n revertir√°:

```solidity
contract Arrays03 {
    uint256[] myArray = [1,2,3,4,5,6];

    function getElementAtIndex(uint256 index) public view returns (uint256) {
        return myArray[index];
    }
}
```

### Longitud

Puedes obtener la longitud de un array con `.length` y usarla para recorrer el array:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Arrays04 {
    uint256[] myArray = [1, 2, 3, 4, 5, 6];

    function sumOfArrayElements() public view returns (uint256) {
        uint256 sum = 0;
        for (uint256 i = 0; i < myArray.length; i++) {
            sum += myArray[i];
        }
        return sum;
    }
}
```

---

## Arrays de Tama√±o Fijo

Supongamos que quieres crear un array para un juego donde habr√° 4 participantes. Si sabes que solo necesitar√°s un arreglo con 4 elementos, es mejor declararlo de antemano:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Arrays05 {
    function getLast(
        uint256[5] calldata myArray
    ) public pure returns (uint256) {
        return myArray[4]; // Aqu√≠ estamos declarando un array de 4 elementos
    }
}
```

Si proporcionas como argumento un array de tama√±o incorrecto obtendr√°s un error.

---

## Arrays Anidados

Aunque son muy raros en la pr√°ctica, Solidity permite declarar **arrays anidados**. Aqu√≠ hay un ejemplo que busca un n√∫mero `3` en un array anidado:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract NestedArrayExample01 {
    function containsAThree(
        uint256[][] calldata nestedArray
    ) public pure returns (bool) {
        for (uint256 i = 0; i < nestedArray.length; i++) {
            for (uint256 j = 0; j < nestedArray[i].length; j++) {
                if (nestedArray[i][j] == 3) {
                    return true;
                }
            }
        }
        return false;
    }
}
```

Puedes probarlo en Remix con este input:  
`[[1,2,4], [5,6,7], [8,9,10]]`  
Por supuesto, deberias obtener false.

Tambi√©n puedes declarar arrays anidados con tama√±os fijos:

```solidity
contract NestedArrayExample02 {
    function getLast(
        uint256[2][3] calldata nestedArray
    ) public pure returns (uint256) {
        return nestedArray[2][1];
    }
}
```

---

Los arrays son estructuras de datos esenciales en Solidity. M√°s adelante ver√°s que los usaremos much√≠simo en los proyectos que vamos a construir. Mientras tanto, ¬°sigamos explorando Solidity! üöÄ
