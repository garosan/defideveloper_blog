---
title: "Aritm칠tica en Solidity: M치s de lo que parece"
datePublished: Sat Dec 07 2024 05:07:31 GMT+0000 (Coordinated Universal Time)
cuid: cm7sob4uv000208l1cu5nd452
slug: aritmetica-en-solidity-mas-de-lo-que-parece
cover: https://cdn.hashnode.com/res/hashnode/image/upload/v1733545825045/ff35487a-34d9-4e15-ba8d-56a05b63926c.png

---


Cuando trabajamos en Solidity, la aritm칠tica funciona un poco diferente a otros lenguajes de programaci칩n. Veamos cuales son las diferencias.

## Operaciones B치sicas

En Solidity, las operaciones b치sicas como suma, resta, multiplicaci칩n y el uso del m칩dulo (`%`) se comportan de la forma esperada.

### Ejemplos

```solidity
uint256 suma = 10 + 5; // Resultado: 15
uint256 resta = 20 - 10 // Resultado: 10
uint256 multiplicacion = 5 * 10 // Resultado: 50
uint256 exponente = 5 ** 3; // Resultado: 125
uint256 modulo = 10 % 4; // Resultado: 2
```

쯈uieres probarlo? Aqu칤 hay un contrato con estas operaciones para que lo ejecutes en Remix:

```solidity
contract Arithmetic01 {
    function sumFunction() public pure returns (uint256) {
        return 10 + 5;
    }

    function substractionFunction() public pure returns (uint256) {
        return 20 - 5;
    }

    function multiplicationFunction() public pure returns (uint256) {
        return 5 * 10;
    }

    function divisionFunction() public pure returns (uint256) {
        return 50 / 2;
    }

    function exponentiationFunction() public pure returns (uint256) {
        return 5 ** 3;
    }

    function moduloFunction() public pure returns (uint256) {
        return 10 % 4;
    }
}
```

---

## Aritm칠tica de Enteros: Aqu칤 no hay decimales

Una caracter칤stica crucial de Solidity es que no tiene n칰meros de punto flotante (decimales). Esto significa que si intentas dividir `5 / 2`, en las versiones recientes de Solidity el compilador te marcar치 un error:

```solidity
uint256 division = 5 / 2;
// Error: TypeError: Return argument type rational_const 5 / 2 is not 
// implicitly convertible to expected type (type of first return variable) 
// uint256.
```

Si necesitas trabajar con porcentajes o fracciones, debes encontrar alternativas. Por ejemplo, para calcular el 15% de 200, no puedes simplemente hacer `200 * .15`. En su lugar, puedes escalar el porcentaje y luego dividir:

```solidity
uint256 porcentaje = (200 * 15) / 100; // porcentaje == 30
```

Otro ejemplo con decimales. 쮺칩mo obtendrias el 7.5% de 200?:

```solidity
uint256 porcentaje = (200 * 75) / 1000; // porcentaje == 15
```

Como trivia, esto es as칤 porque la blockchain debe ser determin칤stica, no puede permitir interpretaciones. Por ejemplo si divides `5 / 3` algunas m치quinas dir치n `1.666666`, otras `1.6666667` y esto causar칤a problemas de consenso en los nodos.

---

## Overflow y underflow

Overflow es cuando una variable trata de contener un n칰mero m치s grande del que puede guardar, y underflow cuando trata de contener un n칰mero m치s peque침o del que puede guardar. Por ejemplo si tenemos `uint8 num = 5` sabemos que un `uint` no puede guardar un n칰mero menor a 0, que pasar칤a si a `num` le restamos 10? 춰Eso es underflow!

En versiones modernas de Solidity (&gt;= 0.8.0), las operaciones que resultan en underflow u overflow solamente se revierten.

Por ejemplo:

```solidity
function subtract(uint256 x, uint256 y) public pure returns (uint256) {
    return x - y; // Revertir치 si por ejemplo x = 2, y = 5
}
```

Si `x` es 2 y `y` es 5, el programa no retornar치 `-3`. En lugar de eso, detendr치 su ejecuci칩n (har치 un revert).

---

## Overflow/underflow controlado: Usando `unchecked`

Si realmente necesitas permitir overflow o underflow, puedes usar un bloque `unchecked`:

```solidity
uint256 x = 2;
uint256 y = 5;

unchecked {
    uint256 z = x - y; // No har치 revert
}
```

Esto no har치 revert, y se puede usar en casos muy espec칤ficos para ahorrar gas. Como principiante, es bueno que sepas que existe, pero no estar치s usandolo pronto.

---

La pr칩xima vez que escribas un smart contract, recuerda estas reglas. 춰La seguridad y precisi칩n son esenciales en blockchain! Sigamos explorando. 游
